<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Generated by NiceXSL 2.0.4 at Fri Apr 23 12:53:23 BST 2004 -->
<!-- From Ed Willink: a stylesheet that shows problems in memory management. In 7.9.1,
with looped=false, it gradually consumes memory, building a long list of Closure objects chained to other
Closure objects -->
<?spec xslt#local-variables?>
<?same-as-1.0 no?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:merge-spans="http://merge-spans.nxsl/" exclude-result-prefixes="merge-spans">
    <xsl:param name="max-span" as="xs:integer" select="50"/>
            <!-- a value of 200 or 1000 is more interesting from the point of view of memory management -->
    <xsl:param name="max-width" as="xs:integer" select="2"/>
    <xsl:param name="looped" as="xs:boolean" select="false()"/>
    <xsl:template match="/">
        <solution>
            <xsl:variable name="problem" as="element()">
                <problem>
                    <xsl:for-each select="0 to $max-span">
                        <xsl:variable name="outer" select="."/>
                        <span>
                            <xsl:attribute name="id">
                                <xsl:value-of select="concat('sp-0-', string($outer))"/>
                            </xsl:attribute>
                            <xsl:for-each select="0 to $max-width">
                                <xsl:element name="{concat('id-',string($outer+.))}"/>
                            </xsl:for-each>
                        </span>
                    </xsl:for-each>
                </problem>
            </xsl:variable>
            <xsl:call-template name="merge-spans:recursive-pass">
                <xsl:with-param name="spans" select="$problem/*"/>
                <xsl:with-param name="depth" select="0"/>
            </xsl:call-template>
        </solution>
    </xsl:template>
    <xsl:template name="merge-spans:recursive-pass" as="element()*">
        <xsl:param name="spans" as="element()*"/>
        <xsl:param name="depth" as="xs:integer"/>
        <xsl:variable name="annotated-spans-D">
            <xsl:call-template name="merge-spans:annotate-spans">
                <xsl:with-param name="spans" select="$spans"/>
                <xsl:with-param name="depth" select="$depth"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="annotated-spans" select="$annotated-spans-D/*"/>
        <xsl:variable name="analysis-D">
            <analysed-spans>
                <xsl:choose>
                    <xsl:when test="$looped">
                        <xsl:for-each select="$annotated-spans/*">
                            <xsl:call-template name="merge-spans:analyse-span">
                                <xsl:with-param name="these-spans" select="."/>
                                <xsl:with-param name="annotated-spans" select="$annotated-spans/*"/>
                            </xsl:call-template>
                        </xsl:for-each>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="merge-spans:analyse-span">
                            <xsl:with-param name="these-spans" select="$annotated-spans/*"/>
                            <xsl:with-param name="annotated-spans" select="$annotated-spans/*"/>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </analysed-spans>
        </xsl:variable>
        <xsl:variable name="analysis" select="$analysis-D/*"/>
        <xsl:for-each select="$analysis/result/span | $analysis/unique/span">
            <xsl:call-template name="merge-spans:remap-indexes">
                <xsl:with-param name="spans" select="$spans"/>
            </xsl:call-template>
        </xsl:for-each>
        <xsl:variable name="more" as="element()*" select="$analysis/first | $analysis/overlap"/>
        <xsl:variable name="recurse-D">
            <recurse-spans>
                <xsl:for-each select="$more/span">
                    <xsl:call-template name="merge-spans:remap-indexes">
                        <xsl:with-param name="spans" select="$spans"/>
                    </xsl:call-template>
                </xsl:for-each>
            </recurse-spans>
        </xsl:variable>
        <xsl:variable name="recurse" select="$recurse-D/*"/>
        <xsl:choose>
            <xsl:when test="not($recurse/span)"/>
            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="$depth &lt; 10">
                        <xsl:call-template name="merge-spans:recursive-pass">
                            <xsl:with-param name="spans" select="$recurse/span"/>
                            <xsl:with-param name="depth" select="$depth + 1"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:otherwise>
                        <Error reason="Maximum merge-spans recursion depth exceeded"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="merge-spans:remap-indexes">
        <xsl:param name="spans" as="element()*"/>
        <xsl:variable name="old-names" as="xs:string*" select="merge-spans:names(*)"/>
        <xsl:variable name="new-names" as="xs:string*" select="merge-spans:names($spans[@id = $old-names]/*)"/>
        <span>
            <xsl:copy-of select="@id"/>
            <xsl:for-each select="distinct-values($new-names)">
                <xsl:sort select="."/>
                <xsl:element name="{.}"/>
            </xsl:for-each>
        </span>
    </xsl:template>
    <xsl:template name="merge-spans:annotate-spans">
        <xsl:param name="spans" as="element()*"/>
        <xsl:param name="depth" as="xs:integer"/>
        <annotated-spans>
            <xsl:for-each select="$spans">
                <xsl:variable name="span-pos" as="xs:integer" select="position()"/>
                <xsl:variable name="names" as="xs:string*" select="merge-spans:names(*)"/>
                <span>
                    <xsl:attribute name="idx">
                        <xsl:value-of select="position()"/>
                    </xsl:attribute>
                    <xsl:attribute name="id">
                        <xsl:value-of select="concat('sp-', string($depth), '-', string(position()))"/>
                    </xsl:attribute>
                    <xsl:variable name="intersections" as="element()*" select="$spans[merge-spans:names(*) = $names]"/>
                    <xsl:attribute name="num-spans">
                        <xsl:value-of select="count($intersections)"/>
                    </xsl:attribute>
                    <xsl:for-each select="$intersections">
                        <xsl:element name="{@id}"/>
                    </xsl:for-each>
                </span>
            </xsl:for-each>
        </annotated-spans>
    </xsl:template>
    <xsl:template name="merge-spans:analyse-span">
        <!-- <xsl:param name="these-spans"/>
        <xsl:param name="annotated-spans"/>-->
       <xsl:param name="these-spans" as="element()*"/>
        <xsl:param name="annotated-spans" as="element()*"/>
        <xsl:for-each select="$these-spans">
            <xsl:variable name="this" select="."/>
            <xsl:choose>
                <xsl:when test="@num-spans &lt;= 1">
                    <result>
                        <xsl:copy-of select="."/>
                    </result>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:variable name="names" as="xs:string*" select="merge-spans:names(*)"/>
                    <xsl:variable name="other-spans" as="element()*" select="$annotated-spans except ."/>
                    <xsl:variable name="covered-by" as="element()*" select="$other-spans[every $n in $names satisfies $n = merge-spans:names(*)]"/>
                    <xsl:variable name="max-cover" as="xs:integer?" select="max($covered-by/@num-spans) cast as xs:integer?"/>
                    <xsl:choose>
                        <xsl:when test="not($max-cover)">
                            <xsl:variable name="overlaps" as="element()*" select="$other-spans[merge-spans:names(*) = $names]"/>
                            <xsl:choose>
                                <xsl:when test="not($overlaps)">
                                    <unique>
                                        <xsl:copy-of select="."/>
                                    </unique>
                                </xsl:when>
                                <xsl:otherwise>
                                    <overlap>
                                        <xsl:copy-of select="."/>
                                    </overlap>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:choose>
                                <xsl:when test="@num-spans &lt; $max-cover"/>
                                <xsl:otherwise>
                                    <xsl:choose>
                                        <xsl:when test="@idx &lt; min($covered-by/@idx)">
                                            <first>
                                                <xsl:copy-of select="."/>
                                            </first>
                                        </xsl:when>
                                        <xsl:otherwise/>
                                    </xsl:choose>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:for-each>
    </xsl:template>
    <xsl:function name="merge-spans:names" as="xs:string*">
        <xsl:param name="nodes" as="element()*"/>
        <xsl:for-each select="$nodes">
            <xsl:sequence select="name()"/>
        </xsl:for-each>
    </xsl:function>
</xsl:stylesheet>
